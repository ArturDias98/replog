# RepLog Backend — Sync API

Backend specification for the RepLog sync system. This API receives change events from the client, applies them to the database with conflict resolution, and returns the current state for the client to merge.

## Table of Contents

1. [Overview](#1-overview)
2. [Data Model (DynamoDB)](#2-data-model-dynamodb)
3. [API Endpoints](#3-api-endpoints)
4. [Entity Processing](#4-entity-processing)
5. [Conflict Resolution](#5-conflict-resolution)
6. [Authentication & Authorization](#6-authentication--authorization)
7. [Security](#7-security)

---

## 1. Overview

### What the backend does

- Receives batches of change events (create, update, delete) from the client
- Applies them to the database, resolving conflicts with last-write-wins
- Returns the current state as nested `WorkOutGroup[]` for the client to merge
- Manages sync metadata (`createdAt`, `updatedAt`, `deletedAt`) — the client does not track these
- Serves as the source of truth for cross-device consistency

### What the backend does NOT do

- Real-time sync (WebSockets, SSE) — sync is pull-based
- Multi-user collaboration — this is a single-user personal app
- Client state management — the client manages its own IndexedDB and sync queue

### Design Principles

- **Idempotent push** — replaying the same change is safe (CREATE skips duplicates, UPDATE uses timestamp comparison, DELETE checks `deletedAt`)
- **Last-write-wins** — conflicts are resolved by comparing timestamps, no user intervention needed
- **Cascading deletes** — deleting a workout deletes all its children
- **Document storage** — each workout is stored as a single DynamoDB item containing the full nested structure (muscle groups, exercises, logs), matching the client's data model

---

## 2. Data Model (DynamoDB)

### 2.1 Table: `replog-workouts`

Each item is a workout document, keyed by the workout's UUID.

#### Key Schema

| PK (`id`) | Description |
|---|---|
| `<workoutId>` | Workout UUID (partition key, no sort key) |

#### GSI: `UserIdIndex`

| GSI PK (`userId`) | Use |
|---|---|
| `<userId>` | Query all workouts for a user |

### 2.2 Item Schema

The workout item stores the entire nested structure as a single document.

| Attribute | Type | Description |
|---|---|---|
| `id` | S (PK) | Workout UUID |
| `userId` | S | Google Auth user ID (GSI PK) |
| `title` | S | Workout name |
| `date` | S | Workout date (YYYY-MM-DD) |
| `orderIndex` | N | Position in list |
| `muscleGroup` | L | List of muscle group objects (nested) |
| `createdAt` | S | ISO 8601 timestamp |
| `updatedAt` | S | ISO 8601 timestamp |
| `deletedAt` | S / null | ISO 8601 timestamp or absent |

The `muscleGroup` attribute contains the full hierarchy:

```json
{
  "id": "w-uuid-1",
  "userId": "google-123",
  "title": "Push Day",
  "date": "2026-02-25",
  "orderIndex": 0,
  "muscleGroup": [
    {
      "id": "mg-uuid-1",
      "workoutId": "w-uuid-1",
      "title": "Chest",
      "date": "2026-02-25",
      "orderIndex": 0,
      "exercises": [
        {
          "id": "ex-uuid-1",
          "muscleGroupId": "mg-uuid-1",
          "title": "Bench Press",
          "orderIndex": 0,
          "log": [
            {
              "id": "log-uuid-1",
              "numberReps": 10,
              "maxWeight": 80,
              "date": "2026-02-25T10:00:00.000Z"
            }
          ]
        }
      ]
    }
  ],
  "createdAt": "2026-02-25T10:00:00.000Z",
  "updatedAt": "2026-02-25T10:05:00.000Z"
}
```

### 2.3 Access Patterns

| Access Pattern | Method |
|---|---|
| Get all workouts for a user | GSI `UserIdIndex`: `userId = <userId>`, filter `deletedAt` absent |
| Get a specific workout | `GetItem(id = <workoutId>)` |
| Find workout by ID (for child changes) | `GetItem(id = <workoutId>)` |

### 2.4 DynamoDB Item Size

DynamoDB has a 400 KB item size limit. A workout with 10 muscle groups, each with 10 exercises, each with 50 logs, fits well within this limit. If a workout ever approaches the limit, it would mean thousands of logs — unlikely for a workout tracker.

---

## 3. API Endpoints

All endpoints require authentication. The `userId` is extracted from the auth token — never from the request body.

### 3.1 `POST /api/sync/push`

Receives a batch of changes from the client and applies them.

**Request:**

```json
{
  "changes": [
    {
      "id": "change-uuid",
      "entityType": "workout",
      "entityId": "entity-uuid",
      "action": "CREATE",
      "timestamp": "2026-02-25T10:00:00.000Z",
      "data": {
        "id": "entity-uuid",
        "title": "Push Day",
        "date": "2026-02-25",
        "userId": "user-123",
        "orderIndex": 0
      },
      "parentId": null
    }
  ],
  "lastSyncedAt": "2026-02-24T20:00:00.000Z"
}
```

**Response (200 OK):**

```json
{
  "acknowledgedChangeIds": ["change-uuid-1", "change-uuid-2"],
  "conflicts": [
    {
      "changeId": "change-uuid-3",
      "resolution": "server_wins",
      "serverVersion": { "...entity fields..." }
    }
  ],
  "serverTimestamp": "2026-02-25T10:05:00.000Z"
}
```

**Response (409 — full re-sync needed):**

```json
{
  "error": "full_sync_required",
  "message": "Server state has diverged too much. Perform a full sync."
}
```

**Processing logic:**

1. Validate auth token, extract `userId`.
2. Validate request body schema.
3. Process each change sequentially (ordered by `timestamp`).
4. Apply each change to the database. Idempotency is inherent (duplicate CREATEs are skipped, UPDATEs use timestamp comparison, DELETEs check `deletedAt`).
5. Return acknowledged IDs, conflicts, and current server timestamp.

See [Section 4 — Entity Processing](#4-entity-processing) for details on how each entity type is handled.

### 3.2 `GET /api/sync/pull`

Returns all workouts for the authenticated user, as nested `WorkOutGroup[]`.

**Response (200 OK):**

```json
{
  "workouts": [
    {
      "id": "w-uuid",
      "title": "Push Day",
      "date": "2026-02-25",
      "userId": "user-123",
      "orderIndex": 0,
      "muscleGroup": [
        {
          "id": "mg-uuid",
          "workoutId": "w-uuid",
          "title": "Chest",
          "date": "2026-02-25",
          "orderIndex": 0,
          "exercises": [
            {
              "id": "ex-uuid",
              "muscleGroupId": "mg-uuid",
              "title": "Bench Press",
              "orderIndex": 0,
              "log": [
                {
                  "id": "log-uuid",
                  "numberReps": 10,
                  "maxWeight": 80,
                  "date": "2026-02-25T10:00:00.000Z"
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "serverTimestamp": "2026-02-25T12:00:00.000Z"
}
```

**Processing logic:**

1. Validate auth token, extract `userId`.
2. Query GSI `UserIdIndex`: `userId = <userId>`, filter `deletedAt` absent.
3. Strip internal attributes (`userId`, `createdAt`, `updatedAt`) from each item.
4. Return the items as `workouts[]` — they are already in the nested `WorkOutGroup` format.

---

## 4. Entity Processing

All entity mutations resolve to reading and writing a workout document. Child entity changes (muscleGroup, exercise, log) require the backend to locate the parent workout, navigate to the nested object, apply the change, and save the updated document.

### Parent Workout Resolution

- **muscleGroup**: `parentId` = `workoutId` → direct `GetItem` by partition key.
- **exercise**: `parentId` = `muscleGroupId` → query the user's workouts, search nested `muscleGroup[]` for a matching `id`.
- **log**: `parentId` = `exerciseId` → query the user's workouts, search nested `muscleGroup[].exercises[]` for a matching `id`.

### 4.1 Workout

| Action | Processing |
|---|---|
| **CREATE** | Insert a new DynamoDB item with `id`, `userId` (from auth token), `title`, `date`, `orderIndex`, empty `muscleGroup: []`, and sync metadata (`createdAt = timestamp`, `updatedAt = timestamp`). If an item with the same `id` already exists, skip (duplicate). |
| **UPDATE** | Get item by `entityId`. Verify `userId` matches. If `deletedAt` is set, skip. If `updatedAt > change.timestamp`, skip and return conflict with server version. Otherwise, apply changed fields (`title`, `date`, `orderIndex`) and set `updatedAt = change.timestamp`. |
| **DELETE** | Get item by `entityId`. Verify `userId` matches. If item doesn't exist or `deletedAt` is already set, skip. Otherwise, set `deletedAt = change.timestamp`. All nested children (muscle groups, exercises, logs) are implicitly deleted with the document. |

**CREATE payload:**

```json
{
  "id": "w-uuid-1",
  "title": "Push Day",
  "date": "2026-02-25",
  "userId": "user-123",
  "orderIndex": 0
}
```

**UPDATE payload (changed fields only):**

```json
{
  "title": "Pull Day",
  "date": "2026-02-26",
  "orderIndex": 2
}
```

### 4.2 Muscle Group

All operations fetch the parent workout document and modify the nested `muscleGroup[]` array.

| Action | Processing |
|---|---|
| **CREATE** | Get workout by `parentId` (= `workoutId`). Verify `userId` matches. If workout is deleted or not found, reject as orphaned. Check that no muscle group with the same `entityId` already exists in the array — if it does, skip. Append the new muscle group object to `muscleGroup[]`. Set `updatedAt = change.timestamp` on the workout. Save. |
| **UPDATE** | Get workout by `parentId`. Find the muscle group in `muscleGroup[]` by `entityId`. If not found or workout is deleted, skip. If `workout.updatedAt > change.timestamp`, skip and return conflict. Apply changed fields (`title`, `date`, `orderIndex`). Set `updatedAt = change.timestamp` on the workout. Save. |
| **DELETE** | Get workout by `parentId`. Find the muscle group in `muscleGroup[]` by `entityId`. If not found or workout is deleted, skip. Remove the muscle group (and all its nested exercises and logs) from the array. Set `updatedAt = change.timestamp` on the workout. Save. |

**CREATE payload:**

```json
{
  "id": "mg-uuid-1",
  "workoutId": "w-uuid-1",
  "title": "Chest",
  "date": "2026-02-25",
  "orderIndex": 0
}
```

**UPDATE payload (changed fields only):**

```json
{
  "title": "Back",
  "date": "2026-02-26",
  "orderIndex": 1
}
```

### 4.3 Exercise

Operations locate the parent workout via the `muscleGroupId`, then navigate to the correct muscle group's `exercises[]` array.

| Action | Processing |
|---|---|
| **CREATE** | Find the workout containing a muscle group with `id = parentId` (= `muscleGroupId`). Verify `userId` matches. If the workout is deleted or the muscle group is not found, reject as orphaned. Check that no exercise with the same `entityId` already exists — if it does, skip. Append the new exercise object (with empty `log: []`) to the muscle group's `exercises[]`. Set `updatedAt = change.timestamp` on the workout. Save. |
| **UPDATE** | Find the workout and muscle group containing the exercise by `entityId`. If not found or workout is deleted, skip. If `workout.updatedAt > change.timestamp`, skip and return conflict. Apply changed fields (`title`, `orderIndex`). Set `updatedAt = change.timestamp` on the workout. Save. |
| **DELETE** | Find the workout and muscle group containing the exercise by `entityId`. If not found or workout is deleted, skip. Remove the exercise (and all its nested logs) from the `exercises[]` array. Set `updatedAt = change.timestamp` on the workout. Save. |

**CREATE payload:**

```json
{
  "id": "ex-uuid-1",
  "muscleGroupId": "mg-uuid-1",
  "title": "Bench Press",
  "orderIndex": 0
}
```

**UPDATE payload (changed fields only):**

```json
{
  "title": "Incline Bench Press",
  "orderIndex": 2
}
```

### 4.4 Log

Operations locate the parent workout via the `exerciseId`, then navigate to the correct exercise's `log[]` array.

| Action | Processing |
|---|---|
| **CREATE** | Find the workout containing an exercise with `id = parentId` (= `exerciseId`). Verify `userId` matches. If the workout is deleted or the exercise is not found, reject as orphaned. Check that no log with the same `entityId` already exists — if it does, skip. Append the new log object to the exercise's `log[]`. Set `updatedAt = change.timestamp` on the workout. Save. |
| **UPDATE** | Find the workout and exercise containing the log by `entityId`. If not found or workout is deleted, skip. If `workout.updatedAt > change.timestamp`, skip and return conflict. Apply changed fields (`numberReps`, `maxWeight`). Set `updatedAt = change.timestamp` on the workout. Save. |
| **DELETE** | Find the workout and exercise containing the log by `entityId`. If not found or workout is deleted, skip. Remove the log from the `log[]` array. Set `updatedAt = change.timestamp` on the workout. Save. |

**CREATE payload:**

```json
{
  "id": "log-uuid-1",
  "numberReps": 10,
  "maxWeight": 80,
  "date": "2026-02-25T10:00:00.000Z"
}
```

**UPDATE payload (changed fields only):**

```json
{
  "numberReps": 12,
  "maxWeight": 85
}
```

### 4.5 Processing Summary

```text
1. Resolve the parent workout:
   - workout → lookup by entityId
   - muscleGroup → lookup by parentId (workoutId)
   - exercise → scan user's workouts for muscleGroup with id = parentId
   - log → scan user's workouts for exercise with id = parentId

2. Validate:
   - Workout exists and belongs to authenticated user
   - Workout is not soft-deleted
   - For child entities: parent node exists in the nested structure

3. Check idempotency:
   - CREATE: skip if entity with same ID already exists
   - UPDATE: skip if workout.updatedAt > change.timestamp (return conflict)
   - DELETE: skip if entity not found

4. Apply mutation:
   - CREATE: append to parent array
   - UPDATE: modify fields in-place
   - DELETE: remove from parent array (cascades nested children)

5. Set workout.updatedAt = change.timestamp

6. Save the workout document back to DynamoDB
```

---

## 5. Conflict Resolution

### 5.1 Strategy: Last-Write-Wins (per workout)

Since the entire workout is stored as a single document, conflict resolution happens at the workout level. The version with the later `updatedAt` timestamp wins.

### 5.2 Rules

| Scenario | Resolution |
|---|---|
| CREATE — entity doesn't exist | Insert |
| CREATE — entity already exists | Skip (duplicate) |
| UPDATE — parent workout not found | Skip (orphaned) |
| UPDATE — parent workout deleted | Skip |
| UPDATE — `workout.updatedAt > change.timestamp` | Server wins — return conflict |
| UPDATE — `workout.updatedAt <= change.timestamp` | Apply update |
| DELETE — entity doesn't exist | Skip |
| DELETE — parent workout deleted | Skip |
| DELETE — entity exists | Remove from document |

### 5.3 Conflict Response Format

```json
{
  "changeId": "change-uuid-3",
  "resolution": "server_wins",
  "serverVersion": {
    "id": "entity-uuid",
    "title": "Server Title",
    "date": "2026-02-25"
  }
}
```

---

## 6. Authentication & Authorization

### 6.1 Authentication

- All endpoints require a valid Google Auth JWT in the `Authorization` header: `Bearer <token>`.
- Validate the JWT against Google's public keys.
- Extract `userId` (Google `sub` claim) from the token.
- No user table or profile item needed — the `userId` from the JWT is stored as an attribute on each workout item.

### 6.2 Authorization

- **Push:** For CREATE, the backend sets `userId` from the auth token. For UPDATE/DELETE, the backend verifies `workout.userId` matches the authenticated user before applying changes.
- **Pull/Full:** GSI query uses `userId` from the auth token — only the user's own data is returned.

### 6.3 User ID Override

The backend **ignores** the `userId` field in client data and always derives it from the auth token.

---

## 7. Security

### 7.1 Transport

- All endpoints must be served over HTTPS.

### 7.2 Input Validation

- Validate all incoming fields against the expected schema (types, required fields, string lengths).
- Reject unknown `entityType` values.
- Reject changes with missing required fields.
- Sanitize text fields (titles) to prevent stored XSS.
- Maximum string lengths: `title` — 200 chars, `date` — 10 chars (YYYY-MM-DD).

### 7.3 Rate Limiting

- Max 10 sync requests per minute per user.
- Max 100 changes per push request.

### 7.4 Idempotency

Push is inherently idempotent — no separate tracking needed:

- **CREATE:** If the entity already exists, the change is skipped.
- **UPDATE:** Timestamp comparison ensures stale updates are rejected.
- **DELETE:** If already deleted (`deletedAt` set), the change is skipped.

### 7.5 Cleanup

- Periodically purge soft-deleted workout items older than a configurable threshold (e.g., 90 days).
